<!DOCTYPE html>
<html>
<head>
    <title>提示词简化修复测试</title>
</head>
<body>
    <h2>提示词简化修复测试</h2>
    
    <script>
        // 模拟修复后的函数
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function isTagContainedIn(shortTag, longTag) {
            // 如果完全相同，不视为包含关系
            if (shortTag.toLowerCase() === longTag.toLowerCase()) {
                return false;
            }
            
            // 方法1：词边界匹配（适用于普通词汇）
            try {
                const wordBoundaryPattern = new RegExp(`\\b${escapeRegex(shortTag)}\\b`, 'i');
                if (wordBoundaryPattern.test(longTag)) {
                    return true;
                }
            } catch (error) {
                // 正则编译失败，继续尝试其他方法
            }
            
            // 方法2：精确子串匹配（适用于复杂词组，如带括号的）
            if (longTag.toLowerCase().includes(shortTag.toLowerCase())) {
                const shortLower = shortTag.toLowerCase();
                const longLower = longTag.toLowerCase();
                const index = longLower.indexOf(shortLower);
                
                if (index !== -1) {
                    // 检查前后字符，确保是完整的词组边界
                    const beforeChar = index > 0 ? longLower[index - 1] : ' ';
                    const afterChar = index + shortLower.length < longLower.length ? 
                                     longLower[index + shortLower.length] : ' ';
                    
                    // 允许空格、逗号、开始/结束作为边界
                    const isValidBoundary = (char) => /[\s,()[\]{}]/.test(char);
                    
                    if (isValidBoundary(beforeChar) && isValidBoundary(afterChar)) {
                        return true;
                    }
                    
                    // 特殊情况：如果短tag是长tag的开头或结尾部分
                    if (index === 0 || index + shortLower.length === longLower.length) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function simplifyTagsFixed(tags) {
            if (!tags || tags.length <= 1) return tags;
            
            // 按长度排序，短的在前面（更可能被包含）
            const sortedTags = tags.slice().sort((a, b) => a.length - b.length);
            const result = [];
            
            for (let i = 0; i < sortedTags.length; i++) {
                const currentTag = sortedTags[i];
                let isContained = false;
                
                // 检查当前tag是否被其他tag包含
                for (let j = i + 1; j < sortedTags.length; j++) {
                    const longerTag = sortedTags[j];
                    
                    if (isTagContainedIn(currentTag, longerTag)) {
                        isContained = true;
                        break;
                    }
                }
                
                // 如果没有被包含，则保留该tag
                if (!isContained) {
                    result.push(currentTag);
                }
            }
            
            // 按首字母排序返回结果
            return result.sort((a, b) => a.localeCompare(b, undefined, {numeric: true, sensitivity: 'base'}));
        }
        
        // 测试用例
        const testCases = [
            {
                name: '基本词汇包含测试',
                input: ['masterpiece', 'hat', 'blue eyes', 'red hat', 'girl'],
                expected: ['blue eyes', 'girl', 'masterpiece', 'red hat']
            },
            {
                name: '复杂词组包含测试',
                input: ['unzen (azur lane)', 'unzen (sojourn through clear seas) (azur lane)'],
                expected: ['unzen (sojourn through clear seas) (azur lane)']
            },
            {
                name: '无包含关系测试',
                input: ['cat', 'dog', 'bird'],
                expected: ['bird', 'cat', 'dog']
            },
            {
                name: '多层包含测试',
                input: ['hat', 'red hat', 'big red hat', 'girl'],
                expected: ['big red hat', 'girl']
            },
            {
                name: '部分匹配避免测试',
                input: ['censored', 'uncensored', 'censorship'],
                expected: ['censored', 'censorship', 'uncensored']
            }
        ];
        
        console.log('=== 提示词简化修复测试 ===');
        
        let allPassed = true;
        const results = [];
        
        testCases.forEach((testCase, index) => {
            console.log(`\n测试 ${index + 1}: ${testCase.name}`);
            console.log('输入:', testCase.input);
            console.log('期望:', testCase.expected);
            
            const actual = simplifyTagsFixed(testCase.input);
            console.log('实际:', actual);
            
            const passed = JSON.stringify(actual) === JSON.stringify(testCase.expected);
            console.log('结果:', passed ? '✅ 通过' : '❌ 失败');
            
            if (!passed) allPassed = false;
            
            results.push({
                ...testCase,
                actual,
                passed
            });
        });
        
        console.log(`\n=== 总体结果: ${allPassed ? '✅ 全部通过' : '❌ 部分失败'} ===`);
        
        // 额外的包含检测测试
        console.log('\n=== 包含检测详细测试 ===');
        const containmentTests = [
            ['hat', 'red hat', true],
            ['unzen (azur lane)', 'unzen (sojourn through clear seas) (azur lane)', true],
            ['censored', 'uncensored', false],
            ['girl', 'girls', false],
            ['masterpiece', 'masterpiece quality', true]
        ];
        
        containmentTests.forEach(([short, long, expected]) => {
            const actual = isTagContainedIn(short, long);
            const passed = actual === expected;
            console.log(`"${short}" 包含在 "${long}" 中: ${actual} (期望: ${expected}) ${passed ? '✅' : '❌'}`);
        });
        
        // 在页面显示结果
        const resultsHtml = results.map((result, index) => {
            const statusClass = result.passed ? 'success' : 'failure';
            return `
                <div class="test-case ${statusClass}" style="margin: 10px; padding: 15px; border: 2px solid ${result.passed ? '#4CAF50' : '#f44336'}; border-radius: 8px; background: ${result.passed ? '#e8f5e9' : '#ffebee'};">
                    <h4>测试 ${index + 1}: ${result.name} ${result.passed ? '✅' : '❌'}</h4>
                    <p><strong>输入:</strong> ${JSON.stringify(result.input)}</p>
                    <p><strong>期望:</strong> ${JSON.stringify(result.expected)}</p>
                    <p><strong>实际:</strong> ${JSON.stringify(result.actual)}</p>
                </div>
            `;
        }).join('');
        
        document.body.innerHTML += `
            <div style="margin: 20px;">
                <h3>测试结果 ${allPassed ? '✅ 全部通过' : '❌ 部分失败'}</h3>
                ${resultsHtml}
            </div>
        `;
    </script>
</body>
</html>