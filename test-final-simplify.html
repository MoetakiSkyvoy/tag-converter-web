<!DOCTYPE html>
<html>
<head>
    <title>最终简化功能测试</title>
</head>
<body>
    <h2>最终简化功能测试</h2>
    
    <script>
        // 模拟最终修复后的函数
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function isTagContainedIn(shortTag, longTag) {
            // 如果完全相同，不视为包含关系
            if (shortTag.toLowerCase() === longTag.toLowerCase()) {
                return false;
            }
            
            // 如果短tag不短于长tag，不可能包含
            if (shortTag.length >= longTag.length) {
                return false;
            }
            
            const shortLower = shortTag.toLowerCase().trim();
            const longLower = longTag.toLowerCase().trim();
            
            // 方法1：直接子串匹配（最宽松）
            if (!longLower.includes(shortLower)) {
                return false; // 如果连子串都不是，肯定不包含
            }
            
            // 方法2：词边界匹配（适用于简单单词）
            try {
                const wordPattern = new RegExp(`\\b${escapeRegex(shortTag)}\\b`, 'i');
                if (wordPattern.test(longTag)) {
                    return true;
                }
            } catch (error) {
                // 正则编译失败，继续其他方法
            }
            
            // 方法3：精确边界匹配（适用于复杂词组）
            const index = longLower.indexOf(shortLower);
            if (index !== -1) {
                // 获取匹配位置的前后字符
                const beforeChar = index > 0 ? longLower.charAt(index - 1) : '';
                const afterChar = index + shortLower.length < longLower.length ? 
                                 longLower.charAt(index + shortLower.length) : '';
                
                // 如果在开头或结尾，直接认为包含
                if (index === 0 || index + shortLower.length === longLower.length) {
                    return true;
                }
                
                // 检查边界字符，允许的分隔符
                const validSeparators = [' ', ',', '(', ')', '[', ']', '{', '}', '-', '_'];
                const beforeValid = validSeparators.includes(beforeChar) || beforeChar === '';
                const afterValid = validSeparators.includes(afterChar) || afterChar === '';
                
                if (beforeValid && afterValid) {
                    return true;
                }
            }
            
            // 方法4：逗号分隔的标签匹配
            const longParts = longTag.split(',').map(part => part.trim().toLowerCase());
            const shortTrimmed = shortTag.trim().toLowerCase();
            
            for (const part of longParts) {
                if (part === shortTrimmed) {
                    return true;
                }
                // 递归检查每个部分
                if (part.length > shortTrimmed.length && part.includes(shortTrimmed)) {
                    const partIndex = part.indexOf(shortTrimmed);
                    if (partIndex !== -1) {
                        const partBefore = partIndex > 0 ? part.charAt(partIndex - 1) : '';
                        const partAfter = partIndex + shortTrimmed.length < part.length ? 
                                        part.charAt(partIndex + shortTrimmed.length) : '';
                        
                        if ((partBefore === '' || /[\s()[\]{}]/.test(partBefore)) &&
                            (partAfter === '' || /[\s()[\]{}]/.test(partAfter))) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        function simplifyTagsFixed(tags) {
            if (!tags || tags.length <= 1) return tags;
            
            // 创建带索引的标签数组，用于保持原始顺序
            const indexedTags = tags.map((tag, index) => ({ tag, originalIndex: index }));
            const result = [];
            
            for (let i = 0; i < indexedTags.length; i++) {
                const currentItem = indexedTags[i];
                let isContained = false;
                
                // 检查当前tag是否被其他tag包含
                for (let j = 0; j < indexedTags.length; j++) {
                    if (i === j) continue; // 跳过自己
                    
                    const otherItem = indexedTags[j];
                    
                    if (isTagContainedIn(currentItem.tag, otherItem.tag)) {
                        isContained = true;
                        break;
                    }
                }
                
                // 如果没有被包含，则保留该tag
                if (!isContained) {
                    result.push(currentItem);
                }
            }
            
            // 按原始输入顺序排序返回结果
            return result
                .sort((a, b) => a.originalIndex - b.originalIndex)
                .map(item => item.tag);
        }
        
        // 测试用例
        const testCases = [
            {
                name: 'Unzen复杂词组测试（关键测试）',
                input: ['unzen (azur lane)', 'unzen (sojourn through clear seas) (azur lane)'],
                expected: ['unzen (sojourn through clear seas) (azur lane)'],
                description: '短的"unzen (azur lane)"应该被长的包含并移除'
            },
            {
                name: '保持原始顺序测试',
                input: ['masterpiece', 'hat', 'blue eyes', 'red hat', 'girl'],
                expected: ['masterpiece', 'blue eyes', 'red hat', 'girl'],
                description: '移除"hat"后保持原始输入顺序'
            },
            {
                name: '避免部分匹配测试',
                input: ['censored', 'uncensored'],
                expected: ['censored', 'uncensored'],
                description: '"censored"不应该被"uncensored"包含'
            },
            {
                name: '多层嵌套测试',
                input: ['hat', 'red hat', 'big red hat'],
                expected: ['big red hat'],
                description: '层层包含，最终只保留最长的'
            },
            {
                name: '括号边界测试',
                input: ['azure', 'azure (color)', 'azure lane'],
                expected: ['azure (color)', 'azure lane'],
                description: '"azure"应该被"azure (color)"包含，但不被"azure lane"包含'
            }
        ];
        
        console.log('=== 最终简化功能测试 ===');
        
        let allPassed = true;
        const results = [];
        
        // 详细测试包含检测
        console.log('\n=== 包含检测详细测试 ===');
        const containmentTests = [
            ['unzen (azur lane)', 'unzen (sojourn through clear seas) (azur lane)', true, '关键测试'],
            ['hat', 'red hat', true, '简单词汇'],
            ['censored', 'uncensored', false, '避免误判'],
            ['azure', 'azure (color)', true, '括号处理'],
            ['girl', 'girls', false, '避免部分匹配']
        ];
        
        containmentTests.forEach(([short, long, expected, desc]) => {
            const actual = isTagContainedIn(short, long);
            const passed = actual === expected;
            console.log(`${desc}: "${short}" → "${long}": ${actual} (期望: ${expected}) ${passed ? '✅' : '❌'}`);
            if (!passed) allPassed = false;
        });
        
        // 测试完整简化流程
        console.log('\n=== 完整简化流程测试 ===');
        testCases.forEach((testCase, index) => {
            console.log(`\n测试 ${index + 1}: ${testCase.name}`);
            console.log('输入:', testCase.input);
            console.log('期望:', testCase.expected);
            
            const actual = simplifyTagsFixed(testCase.input);
            console.log('实际:', actual);
            
            const passed = JSON.stringify(actual) === JSON.stringify(testCase.expected);
            console.log('结果:', passed ? '✅ 通过' : '❌ 失败');
            
            if (!passed) allPassed = false;
            
            results.push({
                ...testCase,
                actual,
                passed
            });
        });
        
        console.log(`\n=== 总体结果: ${allPassed ? '✅ 全部通过' : '❌ 部分失败'} ===`);
        
        // 在页面显示结果
        const resultsHtml = results.map((result, index) => {
            const statusClass = result.passed ? 'success' : 'failure';
            const bgColor = result.passed ? '#e8f5e9' : '#ffebee';
            const borderColor = result.passed ? '#4CAF50' : '#f44336';
            
            return `
                <div style="margin: 15px; padding: 20px; border: 2px solid ${borderColor}; border-radius: 10px; background: ${bgColor};">
                    <h3>测试 ${index + 1}: ${result.name} ${result.passed ? '✅' : '❌'}</h3>
                    <p><strong>描述:</strong> ${result.description}</p>
                    <p><strong>输入:</strong> ${JSON.stringify(result.input)}</p>
                    <p><strong>期望:</strong> ${JSON.stringify(result.expected)}</p>
                    <p><strong>实际:</strong> ${JSON.stringify(result.actual)}</p>
                    ${!result.passed ? '<p style="color: #d32f2f;"><strong>⚠️ 此测试失败，需要进一步调试</strong></p>' : ''}
                </div>
            `;
        }).join('');
        
        document.body.innerHTML += `
            <div style="margin: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                <h3 style="color: ${allPassed ? '#2e7d32' : '#c62828'};">
                    最终测试结果: ${allPassed ? '✅ 全部通过' : '❌ 部分失败'}
                </h3>
                ${resultsHtml}
                
                <div style="margin-top: 30px; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                    <h4>修复要点总结:</h4>
                    <ul>
                        <li>✅ 修复排序问题：保持用户输入的原始顺序</li>
                        <li>${containmentTests[0][2] === isTagContainedIn(containmentTests[0][0], containmentTests[0][1]) ? '✅' : '❌'} 修复Unzen包含检测：支持复杂括号词组</li>
                        <li>✅ 多层匹配算法：词边界+精确边界+逗号分隔</li>
                        <li>✅ 避免误判：防止部分匹配（如censored vs uncensored）</li>
                    </ul>
                    <p><em>请打开浏览器控制台查看详细的测试过程</em></p>
                </div>
            </div>
        `;
    </script>
</body>
</html>