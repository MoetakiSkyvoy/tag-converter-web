<!DOCTYPE html>
<html>
<head>
    <title>Unzen包含检测调试</title>
</head>
<body>
    <h2>Unzen包含检测调试</h2>
    
    <script>
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function currentIsTagContainedIn(shortTag, longTag) {
            console.log(`\n=== 检测 "${shortTag}" 是否包含在 "${longTag}" 中 ===`);
            
            // 如果完全相同，不视为包含关系
            if (shortTag.toLowerCase() === longTag.toLowerCase()) {
                console.log('完全相同，返回 false');
                return false;
            }
            
            // 方法1：词边界匹配（适用于普通词汇）
            try {
                const wordBoundaryPattern = new RegExp(`\\b${escapeRegex(shortTag)}\\b`, 'i');
                console.log(`方法1 - 词边界正则: ${wordBoundaryPattern}`);
                if (wordBoundaryPattern.test(longTag)) {
                    console.log('方法1匹配成功，返回 true');
                    return true;
                }
                console.log('方法1匹配失败');
            } catch (error) {
                console.log('方法1正则编译失败:', error);
            }
            
            // 方法2：精确子串匹配（适用于复杂词组，如带括号的）
            if (longTag.toLowerCase().includes(shortTag.toLowerCase())) {
                console.log('方法2 - 子串包含检测成功');
                
                const shortLower = shortTag.toLowerCase();
                const longLower = longTag.toLowerCase();
                const index = longLower.indexOf(shortLower);
                
                console.log(`子串位置: ${index}`);
                
                if (index !== -1) {
                    // 检查前后字符，确保是完整的词组边界
                    const beforeChar = index > 0 ? longLower[index - 1] : ' ';
                    const afterChar = index + shortLower.length < longLower.length ? 
                                     longLower[index + shortLower.length] : ' ';
                    
                    console.log(`前置字符: "${beforeChar}" (ASCII: ${beforeChar.charCodeAt(0)})`);
                    console.log(`后置字符: "${afterChar}" (ASCII: ${afterChar.charCodeAt(0)})`);
                    
                    // 允许空格、逗号、开始/结束作为边界
                    const isValidBoundary = (char) => /[\s,()[\]{}]/.test(char);
                    
                    const beforeValid = isValidBoundary(beforeChar);
                    const afterValid = isValidBoundary(afterChar);
                    
                    console.log(`前置字符有效: ${beforeValid}`);
                    console.log(`后置字符有效: ${afterValid}`);
                    
                    if (beforeValid && afterValid) {
                        console.log('方法2边界检查成功，返回 true');
                        return true;
                    }
                    
                    // 特殊情况：如果短tag是长tag的开头或结尾部分
                    if (index === 0 || index + shortLower.length === longLower.length) {
                        console.log('方法2特殊情况匹配（开头或结尾），返回 true');
                        return true;
                    }
                }
            } else {
                console.log('方法2 - 子串包含检测失败');
            }
            
            console.log('所有方法都失败，返回 false');
            return false;
        }
        
        // 测试unzen具体情况
        const shortTag = 'unzen (azur lane)';
        const longTag = 'unzen (sojourn through clear seas) (azur lane)';
        
        console.log('=== UNZEN包含检测详细调试 ===');
        console.log('短标签:', shortTag);
        console.log('长标签:', longTag);
        
        const result = currentIsTagContainedIn(shortTag, longTag);
        
        console.log(`\n最终结果: ${result}`);
        console.log(`期望结果: true`);
        console.log(`测试通过: ${result === true ? '✅' : '❌'}`);
        
        // 手动检查子串匹配
        console.log('\n=== 手动子串分析 ===');
        const shortLower = shortTag.toLowerCase();
        const longLower = longTag.toLowerCase();
        console.log('短标签小写:', shortLower);
        console.log('长标签小写:', longLower);
        console.log('包含关系:', longLower.includes(shortLower));
        
        if (longLower.includes(shortLower)) {
            const index = longLower.indexOf(shortLower);
            console.log('匹配位置:', index);
            console.log('匹配的子串:', longLower.substring(index, index + shortLower.length));
            
            // 显示字符分析
            const beforeIndex = index - 1;
            const afterIndex = index + shortLower.length;
            
            console.log('前置位置:', beforeIndex >= 0 ? longLower[beforeIndex] : '(开始)');
            console.log('后置位置:', afterIndex < longLower.length ? longLower[afterIndex] : '(结束)');
        }
        
        // 在页面显示结果
        document.body.innerHTML += `
            <div style="margin: 20px; font-family: monospace;">
                <h3>测试结果</h3>
                <p><strong>短标签:</strong> "${shortTag}"</p>
                <p><strong>长标签:</strong> "${longTag}"</p>
                <p><strong>检测结果:</strong> ${result}</p>
                <p><strong>期望结果:</strong> true</p>
                <p><strong>测试状态:</strong> ${result === true ? '✅ 通过' : '❌ 失败'}</p>
                
                <h4>详细分析（见控制台）</h4>
                <p>请打开浏览器控制台查看详细的匹配过程分析</p>
                
                <h4>可能的问题</h4>
                <p>如果测试失败，可能的原因：</p>
                <ul>
                    <li>词边界 \\b 无法正确处理括号</li>
                    <li>子串匹配的边界检测逻辑有问题</li>
                    <li>正则表达式转义导致的问题</li>
                </ul>
            </div>
        `;
    </script>
</body>
</html>