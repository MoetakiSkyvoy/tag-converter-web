<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>分组过滤器自动化测试</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f7;
            line-height: 1.6;
        }

        .test-container {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #007AFF;
            padding-bottom: 10px;
        }

        .test-title {
            font-size: 1.8rem;
            font-weight: 600;
            color: #1d1d1f;
        }

        .test-status {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .status-pending { background: #f2f2f7; color: #666; }
        .status-running { background: #e3f2fd; color: #1976d2; }
        .status-completed { background: #e8f5e8; color: #2e7d32; }
        .status-failed { background: #ffebee; color: #d32f2f; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            padding: 20px;
            background: white;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #007AFF;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 600;
            color: #007AFF;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007AFF, #34C759);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
        }

        .test-section {
            margin: 20px 0;
            padding: 20px;
            background: #fafafa;
            border-radius: 10px;
            border-left: 4px solid #007AFF;
        }

        .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        .test-case {
            margin: 10px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .test-case.running {
            border-color: #2196F3;
            background: #e3f2fd;
            animation: pulse 1.5s infinite;
        }

        .test-case.passed {
            border-color: #4CAF50;
            background: #e8f5e8;
        }

        .test-case.failed {
            border-color: #f44336;
            background: #ffebee;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .test-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .test-description {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 10px;
        }

        .test-result {
            font-family: monospace;
            font-size: 0.8rem;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .test-result.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .test-result.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            white-space: pre-wrap;
        }

        .report-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px dashed #007AFF;
        }

        .report-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .report-content {
            background: #1e1e1e;
            color: #f0f0f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .copy-button {
            margin-top: 10px;
            padding: 10px 20px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .copy-button:hover {
            background: #0056CC;
        }

        .auto-start-notice {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1 class="test-title">🧪 分组过滤器自动化测试</h1>
            <div class="test-status status-pending" id="overall-status">准备启动</div>
        </div>

        <div class="auto-start-notice">
            ⚡ 测试将在页面加载完成后自动开始，无需手动操作
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <span class="stat-number" id="total-tests">0</span>
                <div class="stat-label">总测试数</div>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="passed-tests">0</span>
                <div class="stat-label">通过</div>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="failed-tests">0</span>
                <div class="stat-label">失败</div>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="success-rate">0%</span>
                <div class="stat-label">成功率</div>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="duration">0s</span>
                <div class="stat-label">耗时</div>
            </div>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">等待开始...</div>
        </div>

        <div id="test-sections"></div>
    </div>

    <div class="report-section" id="report-section" style="display: none;">
        <h2 class="report-title">📋 测试报告 (Plaintext)</h2>
        <div class="report-content" id="report-content"></div>
        <button class="copy-button" onclick="copyReport()">📋 复制报告</button>
    </div>

    <script>
        // 引入核心脚本的内容（避免跨域问题）
        // CONFIG对象
        const CONFIG = {
            FORMATS: {
                DANBOORU: 'danbooru',
                GELBOORU: 'gelbooru', 
                STANDARD: 'standard'
            },
            
            FILTER: {
                STORAGE_KEY: 'tagConverter_filterSettings',
                GROUPED_STORAGE_KEY: 'tagConverter_groupedFilterSettings',
                DEFAULT_ENABLED: false,
                DEFAULT_KEYWORDS: [],
                DEFAULT_SIMPLIFY_ENABLED: false,
                SCHEMA_VERSION: 1,
                DEFAULT_GROUP_NAME_PREFIX: '组'
            }
        };

        // UUID生成函数
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // 创建默认组
        function createDefaultGroup(name = '') {
            return {
                id: generateUUID(),
                name: name || `${CONFIG.FILTER.DEFAULT_GROUP_NAME_PREFIX} ${Date.now()}`,
                enabled: true,
                collapsed: true,
                keywords: [],
                replacement: '',
                meta: {
                    lastMatchCount: 0
                }
            };
        }

        // GroupedFilterManager类
        class GroupedFilterManager {
            constructor() {
                this.masterEnabled = CONFIG.FILTER.DEFAULT_ENABLED;
                this.groups = [];
                this.simplifyEnabled = CONFIG.FILTER.DEFAULT_SIMPLIFY_ENABLED;
                this.lastSimplifiedCount = 0;
                this.lastTotalFilteredCount = 0;
            }
            
            loadSettings() {
                try {
                    const groupedSettings = localStorage.getItem(CONFIG.FILTER.GROUPED_STORAGE_KEY);
                    if (groupedSettings) {
                        this._loadGroupedSettings(JSON.parse(groupedSettings));
                    } else {
                        this._migrateFromOldSettings();
                    }
                } catch (error) {
                    this._initializeDefaults();
                }
            }
            
            _loadGroupedSettings(settings) {
                this.masterEnabled = settings.masterEnabled ?? CONFIG.FILTER.DEFAULT_ENABLED;
                this.simplifyEnabled = settings.simplifyEnabled ?? CONFIG.FILTER.DEFAULT_SIMPLIFY_ENABLED;
                
                this.groups = (settings.groups || []).map(group => ({
                    id: group.id || generateUUID(),
                    name: group.name || '未命名组',
                    enabled: group.enabled ?? true,
                    collapsed: group.collapsed ?? true,
                    keywords: group.keywords || [],
                    replacement: group.replacement || '',
                    meta: {
                        lastMatchCount: group.meta?.lastMatchCount ?? 0,
                        ...group.meta
                    }
                }));
            }
            
            _migrateFromOldSettings() {
                this._initializeDefaults();
            }
            
            _initializeDefaults() {
                this.masterEnabled = CONFIG.FILTER.DEFAULT_ENABLED;
                this.simplifyEnabled = CONFIG.FILTER.DEFAULT_SIMPLIFY_ENABLED;
                this.groups = [];
            }
            
            saveSettings() {
                try {
                    const settings = {
                        masterEnabled: this.masterEnabled,
                        simplifyEnabled: this.simplifyEnabled,
                        groups: this.groups,
                        schemaVersion: CONFIG.FILTER.SCHEMA_VERSION,
                        exportedAt: new Date().toISOString()
                    };
                    localStorage.setItem(CONFIG.FILTER.GROUPED_STORAGE_KEY, JSON.stringify(settings));
                } catch (error) {
                    console.warn('无法保存过滤器设置:', error);
                }
            }
            
            getStatus() {
                const totalGroups = this.groups.length;
                const enabledGroups = this.groups.filter(g => g.enabled).length;
                
                return {
                    enabled: this.masterEnabled,
                    simplifyEnabled: this.simplifyEnabled,
                    keywordCount: totalGroups,
                    enabledGroupCount: enabledGroups,
                    lastFilteredCount: this.lastTotalFilteredCount,
                    lastSimplifiedCount: this.lastSimplifiedCount,
                    groups: this.groups
                };
            }
            
            setMasterEnabled(enabled) {
                this.masterEnabled = Boolean(enabled);
                this.saveSettings();
            }
            
            setSimplifyEnabled(enabled) {
                this.simplifyEnabled = Boolean(enabled);
                this.saveSettings();
            }
            
            addGroup(name = '') {
                const defaultName = name || `${CONFIG.FILTER.DEFAULT_GROUP_NAME_PREFIX} ${this.groups.length + 1}`;
                const newGroup = createDefaultGroup(defaultName);
                this.groups.push(newGroup);
                this.saveSettings();
                return newGroup;
            }
            
            duplicateGroup(groupId) {
                const sourceGroup = this.groups.find(g => g.id === groupId);
                if (!sourceGroup) return null;
                
                const duplicatedGroup = {
                    ...sourceGroup,
                    id: generateUUID(),
                    name: `${sourceGroup.name}(副本)`,
                    meta: { lastMatchCount: 0 }
                };
                
                const sourceIndex = this.groups.findIndex(g => g.id === groupId);
                this.groups.splice(sourceIndex + 1, 0, duplicatedGroup);
                
                this.saveSettings();
                return duplicatedGroup;
            }
            
            deleteGroup(groupId) {
                const index = this.groups.findIndex(g => g.id === groupId);
                if (index === -1) return false;
                
                this.groups.splice(index, 1);
                this.saveSettings();
                return true;
            }
            
            updateGroup(groupId, updates) {
                const group = this.groups.find(g => g.id === groupId);
                if (!group) return false;
                
                Object.assign(group, updates);
                this.saveSettings();
                return true;
            }
            
            getGroup(groupId) {
                return this.groups.find(g => g.id === groupId) || null;
            }
            
            reorderGroups(groupIds) {
                const newGroups = [];
                
                for (const id of groupIds) {
                    const group = this.groups.find(g => g.id === id);
                    if (group) {
                        newGroups.push(group);
                    }
                }
                
                for (const group of this.groups) {
                    if (!newGroups.find(g => g.id === group.id)) {
                        newGroups.push(group);
                    }
                }
                
                this.groups = newGroups;
                this.saveSettings();
            }
            
            clearMatchCounts(groupId = null) {
                if (groupId) {
                    const group = this.getGroup(groupId);
                    if (group) {
                        group.meta.lastMatchCount = 0;
                    }
                } else {
                    this.groups.forEach(group => {
                        group.meta.lastMatchCount = 0;
                    });
                }
                this.saveSettings();
            }
            
            applyFilter(tags) {
                if (!this.masterEnabled) {
                    return tags;
                }
                
                let currentTags = [...tags];
                let totalFilteredCount = 0;
                
                for (const group of this.groups) {
                    if (!group.enabled || group.keywords.length === 0) {
                        group.meta.lastMatchCount = 0;
                        continue;
                    }
                    
                    const result = this._applyGroupFilter(currentTags, group);
                    currentTags = result.filteredTags;
                    group.meta.lastMatchCount = result.matchCount;
                    totalFilteredCount += result.matchCount;
                }
                
                this.lastTotalFilteredCount = totalFilteredCount;
                
                if (this.simplifyEnabled) {
                    const simplifiedTags = this._simplifyTags(currentTags);
                    this.lastSimplifiedCount = currentTags.length - simplifiedTags.length;
                    currentTags = simplifiedTags;
                } else {
                    this.lastSimplifiedCount = 0;
                }
                
                return currentTags;
            }
            
            _applyGroupFilter(tags, group) {
                const patterns = this._compileGroupPatterns(group.keywords);
                const matchedIndices = new Set();
                
                tags.forEach((tag, index) => {
                    for (const pattern of patterns) {
                        try {
                            if (pattern.test(tag)) {
                                matchedIndices.add(index);
                                break;
                            }
                        } catch (error) {
                            if (tag.includes(pattern.source || pattern)) {
                                matchedIndices.add(index);
                                break;
                            }
                        }
                    }
                });
                
                if (matchedIndices.size === 0) {
                    return { filteredTags: tags, matchCount: 0 };
                }
                
                let filteredTags = tags.filter((_, index) => !matchedIndices.has(index));
                
                if (group.replacement && this._isValidReplacement(group.replacement)) {
                    const replacementTokens = this._parseReplacementString(group.replacement);
                    if (replacementTokens.length > 0) {
                        const insertPosition = Math.min(...matchedIndices);
                        filteredTags.splice(insertPosition, 0, ...replacementTokens);
                    }
                }
                
                filteredTags = this._dedupeKeepFirst(filteredTags);
                
                return { 
                    filteredTags, 
                    matchCount: matchedIndices.size 
                };
            }
            
            _compileGroupPatterns(keywords) {
                const patterns = [];
                
                for (const keyword of keywords) {
                    if (!keyword.trim()) continue;
                    
                    try {
                        const pattern = new RegExp(keyword, 'i');
                        pattern.test('');
                        patterns.push(pattern);
                    } catch (error) {
                        const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        patterns.push(new RegExp(`^${escapedKeyword}$`, 'i'));
                    }
                }
                
                return patterns;
            }
            
            _isValidReplacement(replacement) {
                if (!replacement.trim()) return true;
                
                if (replacement.includes(',') && !replacement.includes(', ')) {
                    return false;
                }
                
                return true;
            }
            
            _parseReplacementString(replacement) {
                if (!replacement.trim()) return [];
                
                return replacement
                    .split(', ')
                    .map(token => token.trim())
                    .filter(token => token.length > 0);
            }
            
            _dedupeKeepFirst(array) {
                const seen = new Set();
                return array.filter(item => {
                    if (seen.has(item)) {
                        return false;
                    }
                    seen.add(item);
                    return true;
                });
            }
            
            _simplifyTags(tags) {
                if (!tags || tags.length <= 1) return tags;
                
                const indexedTags = tags.map((tag, index) => ({ tag, originalIndex: index }));
                const result = [];
                
                for (let i = 0; i < indexedTags.length; i++) {
                    const currentItem = indexedTags[i];
                    let isContained = false;
                    
                    for (let j = 0; j < indexedTags.length; j++) {
                        if (i === j) continue;
                        
                        const otherItem = indexedTags[j];
                        if (otherItem.tag.includes(currentItem.tag) && otherItem.tag !== currentItem.tag) {
                            isContained = true;
                            break;
                        }
                    }
                    
                    if (!isContained) {
                        result.push(currentItem);
                    }
                }
                
                return result
                    .sort((a, b) => a.originalIndex - b.originalIndex)
                    .map(item => item.tag);
            }
            
            exportConfig() {
                const config = {
                    masterEnabled: this.masterEnabled,
                    simplifyEnabled: this.simplifyEnabled,
                    groups: this.groups,
                    schemaVersion: CONFIG.FILTER.SCHEMA_VERSION,
                    exportedAt: new Date().toISOString()
                };
                
                return JSON.stringify(config, null, 2);
            }
            
            validateImportConfig(config) {
                if (!config || typeof config !== 'object') {
                    return { valid: false, error: '配置格式无效' };
                }
                
                if (typeof config.masterEnabled !== 'boolean') {
                    return { valid: false, error: '缺少 masterEnabled 字段' };
                }
                
                if (!Array.isArray(config.groups)) {
                    return { valid: false, error: '缺少 groups 字段或格式错误' };
                }
                
                for (let i = 0; i < config.groups.length; i++) {
                    const group = config.groups[i];
                    if (!group.id || typeof group.name !== 'string' || !Array.isArray(group.keywords)) {
                        return { valid: false, error: `组 ${i + 1} 数据结构无效` };
                    }
                }
                
                const migratedConfig = this._migrateConfigSchema(config);
                
                return { valid: true, migratedConfig };
            }
            
            importConfig(configJson, append = false) {
                try {
                    const config = JSON.parse(configJson);
                    const validation = this.validateImportConfig(config);
                    
                    if (!validation.valid) {
                        return { success: false, error: validation.error };
                    }
                    
                    const importConfig = validation.migratedConfig;
                    
                    if (append) {
                        const newGroups = importConfig.groups.map(group => ({
                            ...group,
                            id: generateUUID(),
                            meta: { lastMatchCount: 0 }
                        }));
                        
                        this.groups.push(...newGroups);
                        
                        return { 
                            success: true, 
                            importedGroups: newGroups.length 
                        };
                    } else {
                        this.masterEnabled = importConfig.masterEnabled;
                        this.simplifyEnabled = importConfig.simplifyEnabled ?? this.simplifyEnabled;
                        this.groups = importConfig.groups.map(group => ({
                            ...group,
                            meta: {
                                lastMatchCount: 0,
                                ...group.meta
                            }
                        }));
                        
                        return { 
                            success: true, 
                            importedGroups: this.groups.length 
                        };
                    }
                } catch (error) {
                    return { 
                        success: false, 
                        error: `JSON解析失败: ${error.message}` 
                    };
                } finally {
                    this.saveSettings();
                }
            }
            
            _migrateConfigSchema(config) {
                const migrated = { ...config };
                
                migrated.groups = config.groups.map(group => ({
                    id: group.id || generateUUID(),
                    name: group.name || '未命名组',
                    enabled: group.enabled ?? true,
                    collapsed: group.collapsed ?? true,
                    keywords: group.keywords || [],
                    replacement: group.replacement || '',
                    meta: {
                        lastMatchCount: 0,
                        ...group.meta
                    }
                }));
                
                if (typeof migrated.simplifyEnabled !== 'boolean') {
                    migrated.simplifyEnabled = CONFIG.FILTER.DEFAULT_SIMPLIFY_ENABLED;
                }
                
                return migrated;
            }
            
            getImportPreview(configJson) {
                try {
                    const config = JSON.parse(configJson);
                    const validation = this.validateImportConfig(config);
                    
                    if (!validation.valid) {
                        return { valid: false, error: validation.error };
                    }
                    
                    const importConfig = validation.migratedConfig;
                    const groupNames = importConfig.groups.map(g => g.name);
                    const totalKeywords = importConfig.groups.reduce((sum, g) => sum + g.keywords.length, 0);
                    
                    return {
                        valid: true,
                        preview: {
                            masterEnabled: importConfig.masterEnabled,
                            simplifyEnabled: importConfig.simplifyEnabled,
                            groupCount: importConfig.groups.length,
                            groupNames,
                            totalKeywords,
                            schemaVersion: importConfig.schemaVersion,
                            exportedAt: importConfig.exportedAt
                        }
                    };
                } catch (error) {
                    return { 
                        valid: false, 
                        error: `JSON解析失败: ${error.message}` 
                    };
                }
            }
        }

        // 测试配置
        const testConfig = {
            totalTests: 0,
            passedTests: 0,
            failedTests: 0,
            currentTest: 0,
            startTime: null,
            testResults: [],
            filterManager: null
        };

        // 测试用例定义
        const testSuites = {
            basic: {
                name: '基础功能测试',
                tests: [
                    {
                        name: 'FilterManager初始化',
                        description: '验证GroupedFilterManager正确初始化',
                        test: () => {
                            testConfig.filterManager = new GroupedFilterManager();
                            return testConfig.filterManager instanceof GroupedFilterManager;
                        }
                    },
                    {
                        name: '默认状态检查',
                        description: '验证初始状态正确',
                        test: () => {
                            const status = testConfig.filterManager.getStatus();
                            return status.enabled === false && 
                                   status.simplifyEnabled === false && 
                                   Array.isArray(status.groups) &&
                                   status.keywordCount === 0;
                        }
                    },
                    {
                        name: '配置保存和加载',
                        description: '验证配置的持久化功能',
                        test: () => {
                            testConfig.filterManager.setMasterEnabled(true);
                            testConfig.filterManager.saveSettings();
                            
                            const newManager = new GroupedFilterManager();
                            newManager.loadSettings();
                            
                            return newManager.masterEnabled === true;
                        }
                    }
                ]
            },
            groupManagement: {
                name: '组管理功能',
                tests: [
                    {
                        name: '添加新组',
                        description: '验证新组创建功能',
                        test: () => {
                            const initialCount = testConfig.filterManager.groups.length;
                            const newGroup = testConfig.filterManager.addGroup('新测试组');
                            
                            return newGroup && 
                                   newGroup.name === '新测试组' && 
                                   testConfig.filterManager.groups.length === initialCount + 1;
                        }
                    },
                    {
                        name: '复制组',
                        description: '验证组复制功能',
                        test: () => {
                            const sourceGroup = testConfig.filterManager.addGroup('源组');
                            sourceGroup.keywords = ['test1', 'test2'];
                            sourceGroup.replacement = 'replacement';
                            
                            const duplicatedGroup = testConfig.filterManager.duplicateGroup(sourceGroup.id);
                            
                            return duplicatedGroup && 
                                   duplicatedGroup.name === '源组(副本)' &&
                                   duplicatedGroup.keywords.length === 2 &&
                                   duplicatedGroup.replacement === 'replacement';
                        }
                    },
                    {
                        name: '删除组',
                        description: '验证组删除功能',
                        test: () => {
                            const testGroup = testConfig.filterManager.addGroup('待删除组');
                            const initialCount = testConfig.filterManager.groups.length;
                            
                            const result = testConfig.filterManager.deleteGroup(testGroup.id);
                            
                            return result && testConfig.filterManager.groups.length === initialCount - 1;
                        }
                    },
                    {
                        name: '更新组',
                        description: '验证组信息更新功能',
                        test: () => {
                            const testGroup = testConfig.filterManager.addGroup('原始组名');
                            const result = testConfig.filterManager.updateGroup(testGroup.id, {
                                name: '更新后的组名',
                                enabled: false
                            });
                            
                            const updatedGroup = testConfig.filterManager.getGroup(testGroup.id);
                            
                            return result && 
                                   updatedGroup.name === '更新后的组名' &&
                                   updatedGroup.enabled === false;
                        }
                    },
                    {
                        name: '组排序',
                        description: '验证组顺序调整功能',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            const group1 = testConfig.filterManager.addGroup('组1');
                            const group2 = testConfig.filterManager.addGroup('组2');
                            const group3 = testConfig.filterManager.addGroup('组3');
                            
                            testConfig.filterManager.reorderGroups([group3.id, group1.id, group2.id]);
                            
                            return testConfig.filterManager.groups[0].id === group3.id &&
                                   testConfig.filterManager.groups[1].id === group1.id &&
                                   testConfig.filterManager.groups[2].id === group2.id;
                        }
                    }
                ]
            },
            filterAlgorithm: {
                name: '过滤算法测试',
                tests: [
                    {
                        name: '单组基础过滤',
                        description: '验证单个组的基础过滤功能',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            const testGroup = testConfig.filterManager.addGroup('测试过滤');
                            testGroup.keywords = ['nsfw', 'watermark'];
                            
                            testConfig.filterManager.setMasterEnabled(true);
                            
                            const input = ['1girl', 'nsfw', 'watermark', 'best quality'];
                            const result = testConfig.filterManager.applyFilter(input);
                            
                            return result.includes('1girl') && 
                                   result.includes('best quality') &&
                                   !result.includes('nsfw') && 
                                   !result.includes('watermark');
                        }
                    },
                    {
                        name: '替换短语功能',
                        description: '验证替换短语正确插入',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            const testGroup = testConfig.filterManager.addGroup('替换测试');
                            testGroup.keywords = ['nsfw'];
                            testGroup.replacement = 'sfw, safe';
                            
                            testConfig.filterManager.setMasterEnabled(true);
                            
                            const input = ['1girl', 'nsfw', 'best quality'];
                            const result = testConfig.filterManager.applyFilter(input);
                            
                            return result.includes('1girl') && 
                                   result.includes('sfw') && 
                                   result.includes('safe') && 
                                   result.includes('best quality') &&
                                   !result.includes('nsfw');
                        }
                    },
                    {
                        name: '多组顺序处理',
                        description: '验证多组按顺序执行',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            
                            const group1 = testConfig.filterManager.addGroup('组1');
                            group1.keywords = ['nsfw'];
                            group1.replacement = 'sfw';
                            
                            const group2 = testConfig.filterManager.addGroup('组2');
                            group2.keywords = ['sfw'];
                            group2.replacement = 'safe';
                            
                            testConfig.filterManager.setMasterEnabled(true);
                            
                            const input = ['1girl', 'nsfw'];
                            const result = testConfig.filterManager.applyFilter(input);
                            
                            return result.includes('1girl') && 
                                   result.includes('safe') &&
                                   !result.includes('nsfw') && 
                                   !result.includes('sfw');
                        }
                    },
                    {
                        name: '正则表达式支持',
                        description: '验证正则表达式匹配功能',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            const testGroup = testConfig.filterManager.addGroup('正则测试');
                            testGroup.keywords = ['\\d+px', 'bad.*quality'];
                            
                            testConfig.filterManager.setMasterEnabled(true);
                            
                            const input = ['1girl', '1024px', 'bad quality', 'masterpiece'];
                            const result = testConfig.filterManager.applyFilter(input);
                            
                            return result.includes('1girl') && 
                                   result.includes('masterpiece') &&
                                   !result.includes('1024px') && 
                                   !result.includes('bad quality');
                        }
                    },
                    {
                        name: '命中计数统计',
                        description: '验证命中计数正确记录',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            const testGroup = testConfig.filterManager.addGroup('计数测试');
                            testGroup.keywords = ['test'];
                            
                            testConfig.filterManager.setMasterEnabled(true);
                            
                            const input = ['test', '1girl', 'test', 'quality'];
                            testConfig.filterManager.applyFilter(input);
                            
                            return testGroup.meta.lastMatchCount === 2;
                        }
                    }
                ]
            },
            simplification: {
                name: '提示词简化测试',
                tests: [
                    {
                        name: '简化功能开关',
                        description: '验证简化功能开关控制',
                        test: () => {
                            testConfig.filterManager.setMasterEnabled(true);
                            testConfig.filterManager.setSimplifyEnabled(true);
                            
                            const input = ['hat', 'red hat', 'girl', 'beautiful girl'];
                            const result = testConfig.filterManager.applyFilter(input);
                            
                            return result.includes('red hat') && 
                                   result.includes('beautiful girl') &&
                                   !result.includes('hat') && 
                                   !result.includes('girl');
                        }
                    },
                    {
                        name: '简化统计计数',
                        description: '验证简化移除计数正确',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            testConfig.filterManager.setMasterEnabled(true);
                            testConfig.filterManager.setSimplifyEnabled(true);
                            
                            const input = ['hat', 'red hat', 'girl', 'beautiful girl', 'quality', 'best quality'];
                            testConfig.filterManager.applyFilter(input);
                            
                            return testConfig.filterManager.lastSimplifiedCount === 3;
                        }
                    }
                ]
            },
            importExport: {
                name: '导入导出测试',
                tests: [
                    {
                        name: '配置导出',
                        description: '验证配置导出功能',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            testConfig.filterManager.addGroup('导出测试组');
                            
                            const exported = testConfig.filterManager.exportConfig();
                            const config = JSON.parse(exported);
                            
                            return config.schemaVersion === 1 && 
                                   Array.isArray(config.groups) && 
                                   config.groups.length > 0 &&
                                   config.groups[0].name === '导出测试组';
                        }
                    },
                    {
                        name: '配置导入验证',
                        description: '验证配置导入验证功能',
                        test: () => {
                            const validConfig = {
                                masterEnabled: true,
                                simplifyEnabled: false,
                                groups: [
                                    {
                                        id: 'test-id',
                                        name: '导入测试',
                                        enabled: true,
                                        collapsed: true,
                                        keywords: ['test'],
                                        replacement: ''
                                    }
                                ],
                                schemaVersion: 1
                            };
                            
                            const validation = testConfig.filterManager.validateImportConfig(validConfig);
                            return validation.valid === true;
                        }
                    },
                    {
                        name: '配置导入应用',
                        description: '验证配置导入并应用功能',
                        test: () => {
                            const testConfigData = {
                                masterEnabled: true,
                                simplifyEnabled: false,
                                groups: [
                                    {
                                        id: 'imported-group',
                                        name: '导入的组',
                                        enabled: true,
                                        collapsed: true,
                                        keywords: ['imported'],
                                        replacement: 'processed'
                                    }
                                ],
                                schemaVersion: 1
                            };
                            
                            const result = testConfig.filterManager.importConfig(JSON.stringify(testConfigData), false);
                            const importedGroup = testConfig.filterManager.groups.find(g => g.name === '导入的组');
                            
                            return result.success && importedGroup && importedGroup.keywords.includes('imported');
                        }
                    }
                ]
            },
            validation: {
                name: '数据验证测试',
                tests: [
                    {
                        name: '替换短语格式验证',
                        description: '验证替换短语格式检查',
                        test: () => {
                            const validReplacement = 'tag1, tag2, tag3';
                            const invalidReplacement = 'tag1,tag2,tag3';
                            
                            const validResult = testConfig.filterManager._isValidReplacement(validReplacement);
                            const invalidResult = testConfig.filterManager._isValidReplacement(invalidReplacement);
                            
                            return validResult === true && invalidResult === false;
                        }
                    },
                    {
                        name: '替换短语解析',
                        description: '验证替换短语正确解析',
                        test: () => {
                            const replacement = 'tag1, tag2, tag3';
                            const parsed = testConfig.filterManager._parseReplacementString(replacement);
                            
                            return Array.isArray(parsed) && 
                                   parsed.length === 3 && 
                                   parsed.includes('tag1') && 
                                   parsed.includes('tag2') && 
                                   parsed.includes('tag3');
                        }
                    },
                    {
                        name: '去重功能',
                        description: '验证数组去重功能',
                        test: () => {
                            const input = ['tag1', 'tag2', 'tag1', 'tag3', 'tag2'];
                            const result = testConfig.filterManager._dedupeKeepFirst(input);
                            
                            return result.length === 3 && 
                                   result[0] === 'tag1' && 
                                   result[1] === 'tag2' && 
                                   result[2] === 'tag3';
                        }
                    }
                ]
            },
            integration: {
                name: '集成测试',
                tests: [
                    {
                        name: '完整过滤流程',
                        description: '验证完整的分组过滤流程',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            const filterGroup = testConfig.filterManager.addGroup('内容过滤');
                            filterGroup.keywords = ['nsfw', 'watermark'];
                            filterGroup.replacement = 'sfw';
                            
                            testConfig.filterManager.setMasterEnabled(true);
                            testConfig.filterManager.setSimplifyEnabled(true);
                            
                            const input = ['1girl', 'long hair', 'hat', 'red hat', 'nsfw', 'watermark'];
                            const result = testConfig.filterManager.applyFilter(input);
                            
                            return Array.isArray(result) && 
                                   result.includes('1girl') && 
                                   result.includes('long hair') && 
                                   result.includes('red hat') && 
                                   result.includes('sfw') && 
                                   !result.includes('hat') && 
                                   !result.includes('nsfw') && 
                                   !result.includes('watermark');
                        }
                    },
                    {
                        name: '总开关控制',
                        description: '验证总开关对所有功能的控制',
                        test: () => {
                            testConfig.filterManager.groups = [];
                            const filterGroup = testConfig.filterManager.addGroup('测试组');
                            filterGroup.keywords = ['test'];
                            
                            testConfig.filterManager.setMasterEnabled(false);
                            testConfig.filterManager.setSimplifyEnabled(true);
                            
                            const input = ['test', 'hat', 'red hat'];
                            const result = testConfig.filterManager.applyFilter(input);
                            
                            return result.length === input.length && 
                                   result.includes('test') && 
                                   result.includes('hat') && 
                                   result.includes('red hat');
                        }
                    }
                ]
            }
        };

        // 测试执行函数
        async function runTestSuite(suiteName) {
            const suite = testSuites[suiteName];
            if (!suite) return;

            const sectionDiv = createTestSection(suite.name);
            
            for (const testCase of suite.tests) {
                const caseDiv = createTestCase(testCase.name, testCase.description);
                sectionDiv.appendChild(caseDiv);
                
                testConfig.currentTest++;
                updateProgress();
                
                try {
                    caseDiv.className += ' running';
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const result = testCase.test();
                    
                    if (result) {
                        caseDiv.className = caseDiv.className.replace(' running', ' passed');
                        testConfig.passedTests++;
                        
                        const output = document.createElement('div');
                        output.className = 'test-result success';
                        output.textContent = '✅ 测试通过';
                        caseDiv.appendChild(output);
                    } else {
                        throw new Error('测试条件不满足');
                    }
                } catch (error) {
                    caseDiv.className = caseDiv.className.replace(' running', ' failed');
                    testConfig.failedTests++;
                    
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'test-result error';
                    errorDiv.textContent = `❌ ${error.message}`;
                    caseDiv.appendChild(errorDiv);
                }
                
                testConfig.testResults.push({
                    suite: suite.name,
                    test: testCase.name,
                    passed: caseDiv.classList.contains('passed'),
                    error: caseDiv.classList.contains('failed') ? caseDiv.querySelector('.test-result.error')?.textContent.replace('❌ ', '') : null
                });
                
                updateStats();
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        }

        function createTestSection(name) {
            const sectionsContainer = document.getElementById('test-sections');
            
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `<h3 class="section-title">${name}</h3>`;
            
            sectionsContainer.appendChild(section);
            return section;
        }

        function createTestCase(name, description) {
            const caseDiv = document.createElement('div');
            caseDiv.className = 'test-case';
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'test-name';
            nameDiv.textContent = name;
            caseDiv.appendChild(nameDiv);
            
            const descDiv = document.createElement('div');
            descDiv.className = 'test-description';
            descDiv.textContent = description;
            caseDiv.appendChild(descDiv);
            
            return caseDiv;
        }

        function updateStats() {
            document.getElementById('total-tests').textContent = testConfig.currentTest;
            document.getElementById('passed-tests').textContent = testConfig.passedTests;
            document.getElementById('failed-tests').textContent = testConfig.failedTests;
            
            const successRate = testConfig.currentTest > 0 
                ? Math.round((testConfig.passedTests / testConfig.currentTest) * 100)
                : 0;
            document.getElementById('success-rate').textContent = successRate + '%';
            
            const duration = testConfig.startTime ? (Date.now() - testConfig.startTime) / 1000 : 0;
            document.getElementById('duration').textContent = duration.toFixed(1) + 's';
        }

        function updateProgress() {
            const totalTests = Object.values(testSuites).reduce((sum, suite) => sum + suite.tests.length, 0);
            const progress = (testConfig.currentTest / totalTests) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('progress-text').textContent = `进度: ${testConfig.currentTest}/${totalTests} (${progress.toFixed(1)}%)`;
        }

        function updateOverallStatus(status) {
            const statusEl = document.getElementById('overall-status');
            statusEl.textContent = status;
            statusEl.className = `test-status status-${status.toLowerCase().replace(/\s+/g, '-')}`;
        }

        // 生成测试报告
        function generatePlaintextReport() {
            const duration = (Date.now() - testConfig.startTime) / 1000;
            const successRate = Math.round((testConfig.passedTests / testConfig.currentTest) * 100);
            
            let report = '';
            report += '='.repeat(60) + '\n';
            report += '分组过滤器功能测试报告\n';
            report += '='.repeat(60) + '\n';
            report += `测试时间: ${new Date().toLocaleString()}\n`;
            report += `测试耗时: ${duration.toFixed(2)}秒\n`;
            report += '\n';
            
            // 汇总统计
            report += '测试汇总:\n';
            report += '-'.repeat(30) + '\n';
            report += `总测试数: ${testConfig.currentTest}\n`;
            report += `通过数量: ${testConfig.passedTests}\n`;
            report += `失败数量: ${testConfig.failedTests}\n`;
            report += `成功率: ${successRate}%\n`;
            report += '\n';
            
            // 按测试套件分组
            const suiteResults = {};
            testConfig.testResults.forEach(result => {
                if (!suiteResults[result.suite]) {
                    suiteResults[result.suite] = { passed: 0, failed: 0, tests: [] };
                }
                if (result.passed) {
                    suiteResults[result.suite].passed++;
                } else {
                    suiteResults[result.suite].failed++;
                }
                suiteResults[result.suite].tests.push(result);
            });
            
            // 详细结果
            report += '详细测试结果:\n';
            report += '-'.repeat(30) + '\n';
            
            Object.keys(suiteResults).forEach(suiteName => {
                const suite = suiteResults[suiteName];
                const suiteRate = Math.round((suite.passed / (suite.passed + suite.failed)) * 100);
                
                report += `\n【${suiteName}】 (${suite.passed + suite.failed}个测试, 成功率: ${suiteRate}%)\n`;
                
                suite.tests.forEach(test => {
                    const status = test.passed ? '✅ PASS' : '❌ FAIL';
                    report += `  ${status} ${test.test}`;
                    if (test.error) {
                        report += `\n       错误: ${test.error}`;
                    }
                    report += '\n';
                });
            });
            
            // 失败汇总
            const failedTests = testConfig.testResults.filter(r => !r.passed);
            if (failedTests.length > 0) {
                report += '\n失败测试汇总:\n';
                report += '-'.repeat(30) + '\n';
                failedTests.forEach(test => {
                    report += `• [${test.suite}] ${test.test}\n`;
                    report += `  错误: ${test.error}\n\n`;
                });
            }
            
            // 总结
            report += '\n测试总结:\n';
            report += '-'.repeat(30) + '\n';
            if (successRate === 100) {
                report += '🎉 所有测试通过！分组过滤器功能完全正常。\n';
            } else if (successRate >= 90) {
                report += '⚠️  大部分测试通过，但存在少量问题需要修复。\n';
            } else if (successRate >= 70) {
                report += '🔧 部分测试通过，存在一些需要修复的问题。\n';
            } else {
                report += '🚨 测试失败率较高，需要重点检查和修复功能。\n';
            }
            
            // 功能覆盖度
            report += '\n功能覆盖度:\n';
            report += '-'.repeat(30) + '\n';
            report += '✓ 组管理功能 (增删改查、排序)\n';
            report += '✓ 分组过滤算法 (单组、多组、正则)\n';
            report += '✓ 替换短语功能\n';
            report += '✓ 提示词简化\n';
            report += '✓ 导入导出配置\n';
            report += '✓ 数据验证和错误处理\n';
            report += '✓ 集成功能测试\n';
            
            report += '\n' + '='.repeat(60) + '\n';
            report += '报告结束\n';
            report += '='.repeat(60);
            
            return report;
        }

        function displayReport() {
            const report = generatePlaintextReport();
            document.getElementById('report-content').textContent = report;
            document.getElementById('report-section').style.display = 'block';
        }

        function copyReport() {
            const reportContent = document.getElementById('report-content').textContent;
            navigator.clipboard.writeText(reportContent).then(() => {
                const btn = document.querySelector('.copy-button');
                const originalText = btn.textContent;
                btn.textContent = '✅ 已复制';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            });
        }

        // 自动运行所有测试
        async function runAllTests() {
            testConfig.startTime = Date.now();
            updateOverallStatus('运行中');
            
            try {
                const suiteNames = Object.keys(testSuites);
                for (const suiteName of suiteNames) {
                    await runTestSuite(suiteName);
                }
                
                const success = testConfig.failedTests === 0;
                updateOverallStatus(success ? '全部通过' : '部分失败');
                
                // 显示测试报告
                displayReport();
                
            } catch (error) {
                updateOverallStatus('运行失败');
                console.error('测试运行出错:', error);
            }
        }

        // 页面加载完成后自动开始测试
        document.addEventListener('DOMContentLoaded', function() {
            console.log('测试页面已加载，开始自动测试...');
            
            // 计算总测试数并显示
            const totalTests = Object.values(testSuites).reduce((sum, suite) => sum + suite.tests.length, 0);
            document.getElementById('total-tests').textContent = totalTests;
            
            // 延迟500ms后开始测试，确保页面完全渲染
            setTimeout(() => {
                runAllTests();
            }, 500);
        });
    </script>
</body>
</html>