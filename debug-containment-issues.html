<!DOCTYPE html>
<html>
<head>
    <title>包含检测问题调试</title>
</head>
<body>
    <h2>包含检测问题调试</h2>
    
    <script>
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function debugIsTagContainedIn(shortTag, longTag) {
            console.log(`\n=== 调试: "${shortTag}" 是否包含在 "${longTag}" 中 ===`);
            
            // 如果完全相同，不视为包含关系
            if (shortTag.toLowerCase() === longTag.toLowerCase()) {
                console.log('完全相同，返回 false');
                return false;
            }
            
            // 如果短tag不短于长tag，不可能包含
            if (shortTag.length >= longTag.length) {
                console.log(`长度检查失败: ${shortTag.length} >= ${longTag.length}，返回 false`);
                return false;
            }
            
            const shortLower = shortTag.toLowerCase().trim();
            const longLower = longTag.toLowerCase().trim();
            console.log(`处理后: "${shortLower}" vs "${longLower}"`);
            
            // 方法1：直接子串匹配（最宽松）
            const includesResult = longLower.includes(shortLower);
            console.log(`方法1 - 子串包含: ${includesResult}`);
            if (!includesResult) {
                console.log('子串都不包含，返回 false');
                return false;
            }
            
            // 方法2：词边界匹配（适用于简单单词）
            try {
                const wordPattern = new RegExp(`\\b${escapeRegex(shortTag)}\\b`, 'i');
                console.log(`方法2 - 词边界正则: ${wordPattern}`);
                const wordResult = wordPattern.test(longTag);
                console.log(`方法2 - 词边界匹配结果: ${wordResult}`);
                if (wordResult) {
                    console.log('词边界匹配成功，返回 true');
                    return true;
                }
            } catch (error) {
                console.log('方法2 - 正则编译失败:', error);
            }
            
            // 方法3：精确边界匹配（适用于复杂词组）
            const index = longLower.indexOf(shortLower);
            console.log(`方法3 - 子串位置: ${index}`);
            
            if (index !== -1) {
                const beforeChar = index > 0 ? longLower.charAt(index - 1) : '';
                const afterChar = index + shortLower.length < longLower.length ? 
                                 longLower.charAt(index + shortLower.length) : '';
                
                console.log(`前置字符: "${beforeChar}" (${beforeChar ? beforeChar.charCodeAt(0) : 'empty'})`);
                console.log(`后置字符: "${afterChar}" (${afterChar ? afterChar.charCodeAt(0) : 'empty'})`);
                
                // 如果在开头或结尾，直接认为包含
                if (index === 0 || index + shortLower.length === longLower.length) {
                    console.log('开头或结尾匹配，返回 true');
                    return true;
                }
                
                // 检查边界字符，允许的分隔符
                const validSeparators = [' ', ',', '(', ')', '[', ']', '{', '}', '-', '_'];
                const beforeValid = validSeparators.includes(beforeChar) || beforeChar === '';
                const afterValid = validSeparators.includes(afterChar) || afterChar === '';
                
                console.log(`前置字符有效: ${beforeValid}`);
                console.log(`后置字符有效: ${afterValid}`);
                
                if (beforeValid && afterValid) {
                    console.log('边界检查通过，返回 true');
                    return true;
                } else {
                    console.log('边界检查失败');
                }
            }
            
            // 方法4：逗号分隔的标签匹配
            console.log('方法4 - 逗号分隔检测');
            const longParts = longTag.split(',').map(part => part.trim().toLowerCase());
            const shortTrimmed = shortTag.trim().toLowerCase();
            
            console.log('长标签分割:', longParts);
            console.log('短标签:', shortTrimmed);
            
            for (const part of longParts) {
                if (part === shortTrimmed) {
                    console.log(`完全匹配部分 "${part}"，返回 true`);
                    return true;
                }
                
                if (part.length > shortTrimmed.length && part.includes(shortTrimmed)) {
                    console.log(`部分 "${part}" 包含短标签`);
                    const partIndex = part.indexOf(shortTrimmed);
                    if (partIndex !== -1) {
                        const partBefore = partIndex > 0 ? part.charAt(partIndex - 1) : '';
                        const partAfter = partIndex + shortTrimmed.length < part.length ? 
                                        part.charAt(partIndex + shortTrimmed.length) : '';
                        
                        console.log(`部分内匹配: 前="${partBefore}" 后="${partAfter}"`);
                        
                        if ((partBefore === '' || /[\s()[\]{}]/.test(partBefore)) &&
                            (partAfter === '' || /[\s()[\]{}]/.test(partAfter))) {
                            console.log('部分内匹配成功，返回 true');
                            return true;
                        }
                    }
                }
            }
            
            console.log('所有方法都失败，返回 false');
            return false;
        }
        
        // 测试失败的案例
        console.log('=== 失败案例调试 ===');
        
        // 案例1: unzen
        console.log('\n1. Unzen案例:');
        const unzenResult = debugIsTagContainedIn('unzen (azur lane)', 'unzen (sojourn through clear seas) (azur lane)');
        console.log(`结果: ${unzenResult}, 期望: true`);
        
        // 案例2: censored
        console.log('\n2. Censored案例:');
        const censoredResult = debugIsTagContainedIn('censored', 'uncensored');
        console.log(`结果: ${censoredResult}, 期望: false`);
        
        // 手动分析unzen情况
        console.log('\n=== Unzen手动分析 ===');
        const short = 'unzen (azur lane)';
        const long = 'unzen (sojourn through clear seas) (azur lane)';
        const shortLower = short.toLowerCase();
        const longLower = long.toLowerCase();
        
        console.log('短:', shortLower);
        console.log('长:', longLower);
        console.log('包含:', longLower.includes(shortLower));
        
        if (longLower.includes(shortLower)) {
            const idx = longLower.indexOf(shortLower);
            console.log('位置:', idx);
            console.log('应该在开头，idx === 0:', idx === 0);
            console.log('应该在结尾，idx + length === total:', idx + shortLower.length === longLower.length);
        }
        
        // 分析为什么unzen检测失败
        console.log('\n=== Unzen失败原因分析 ===');
        console.log('预期: "unzen (azur lane)" 应该匹配 "unzen (sojourn through clear seas) (azur lane)" 的结尾部分');
        console.log('但实际上，"unzen (azur lane)" 并不是完整地出现在长字符串中');
        console.log('长字符串结尾是: "(azur lane)"，而不是 "unzen (azur lane)"');
        console.log('这是一个逻辑错误：我们需要检查结尾匹配，而不是简单的子串包含');
    </script>
</body>
</html>