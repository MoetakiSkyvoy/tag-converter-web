<!DOCTYPE html>
<html>
<head>
    <title>修复后的包含检测测试</title>
</head>
<body>
    <h2>修复后的包含检测测试</h2>
    
    <script>
        // 模拟修复后的完整逻辑
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function parseTagStructure(tag) {
            const bracketContents = [];
            let cleanTag = tag;
            
            // 提取所有括号内容
            const bracketMatches = tag.matchAll(/\(([^)]+)\)/g);
            for (const match of bracketMatches) {
                bracketContents.push(match[1].trim());
                cleanTag = cleanTag.replace(match[0], '').trim();
            }
            
            // 剩余的就是主要词汇
            const mainWord = cleanTag.trim();
            
            return {
                mainWord,
                bracketContents
            };
        }
        
        function isSimpleWordContained(shortTag, longTag) {
            try {
                // 使用严格的词边界匹配
                const pattern = new RegExp(`\\b${escapeRegex(shortTag)}\\b`, 'i');
                const result = pattern.test(longTag);
                
                // 额外检查：确保不是部分匹配
                if (result) {
                    const shortLower = shortTag.toLowerCase();
                    const longLower = longTag.toLowerCase();
                    
                    // 如果长标签只是在短标签前后加了字符，则不认为是包含
                    if (longLower.startsWith(shortLower) || longLower.endsWith(shortLower)) {
                        // 检查是否只是前缀或后缀
                        if (longLower === shortLower) {
                            return false; // 完全相同
                        }
                        
                        // 如果是连续的字母数字组合（如censored/uncensored），则不认为包含
                        const beforeMatch = longLower.indexOf(shortLower);
                        if (beforeMatch >= 0) {
                            const beforeChar = beforeMatch > 0 ? longLower[beforeMatch - 1] : '';
                            const afterChar = beforeMatch + shortLower.length < longLower.length ? 
                                            longLower[beforeMatch + shortLower.length] : '';
                            
                            // 如果前后都是字母数字，则认为是一个连续单词的一部分
                            if (/[a-z0-9]/.test(beforeChar) || /[a-z0-9]/.test(afterChar)) {
                                return false;
                            }
                        }
                    }
                }
                
                return result;
            } catch (error) {
                return false;
            }
        }
        
        function isComplexPhraseContained(shortTag, longTag) {
            const shortParts = parseTagStructure(shortTag);
            const longParts = parseTagStructure(longTag);
            
            // 如果短标签的所有重要部分都出现在长标签中，则认为包含
            if (shortParts.mainWord && longParts.mainWord) {
                // 主词必须完全匹配
                if (shortParts.mainWord.toLowerCase() !== longParts.mainWord.toLowerCase()) {
                    return false;
                }
                
                // 检查括号内容的包含关系
                for (const shortBracket of shortParts.bracketContents) {
                    let found = false;
                    for (const longBracket of longParts.bracketContents) {
                        if (longBracket.toLowerCase().includes(shortBracket.toLowerCase())) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        return false;
                    }
                }
                
                return true;
            }
            
            return false;
        }
        
        function isTagContainedIn(shortTag, longTag) {
            // 如果完全相同，不视为包含关系
            if (shortTag.toLowerCase() === longTag.toLowerCase()) {
                return false;
            }
            
            // 如果短tag不短于长tag，不可能包含
            if (shortTag.length >= longTag.length) {
                return false;
            }
            
            const shortTrimmed = shortTag.trim();
            const longTrimmed = longTag.trim();
            
            // 方法1：简单词汇的词边界匹配
            if (isSimpleWordContained(shortTrimmed, longTrimmed)) {
                return true;
            }
            
            // 方法2：复杂词组的语义包含检测
            if (isComplexPhraseContained(shortTrimmed, longTrimmed)) {
                return true;
            }
            
            return false;
        }
        
        function simplifyTagsFixed(tags) {
            if (!tags || tags.length <= 1) return tags;
            
            // 创建带索引的标签数组，用于保持原始顺序
            const indexedTags = tags.map((tag, index) => ({ tag, originalIndex: index }));
            const result = [];
            
            for (let i = 0; i < indexedTags.length; i++) {
                const currentItem = indexedTags[i];
                let isContained = false;
                
                // 检查当前tag是否被其他tag包含
                for (let j = 0; j < indexedTags.length; j++) {
                    if (i === j) continue; // 跳过自己
                    
                    const otherItem = indexedTags[j];
                    
                    if (isTagContainedIn(currentItem.tag, otherItem.tag)) {
                        isContained = true;
                        break;
                    }
                }
                
                // 如果没有被包含，则保留该tag
                if (!isContained) {
                    result.push(currentItem);
                }
            }
            
            // 按原始输入顺序排序返回结果
            return result
                .sort((a, b) => a.originalIndex - b.originalIndex)
                .map(item => item.tag);
        }
        
        // 测试用例
        console.log('=== 修复后的包含检测测试 ===');
        
        // 详细测试每个包含检测
        const containmentTests = [
            // 基本测试
            ['hat', 'red hat', true, '简单词汇包含'],
            ['censored', 'uncensored', false, '避免部分匹配'],
            ['girl', 'girls', false, '避免词尾匹配'],
            
            // 复杂词组测试
            ['unzen (azur lane)', 'unzen (sojourn through clear seas) (azur lane)', true, 'Unzen复杂词组'],
            ['azure', 'azure (color)', true, '主词匹配'],
            ['azure lane', 'azure (color)', false, '不同修饰'],
            
            // 边界情况
            ['test', 'testing', false, '避免前缀匹配'],
            ['cat', 'category', false, '避免前缀匹配'],
        ];
        
        console.log('\n=== 包含检测详细测试 ===');
        let containmentPassed = 0;
        containmentTests.forEach(([short, long, expected, desc]) => {
            const actual = isTagContainedIn(short, long);
            const passed = actual === expected;
            if (passed) containmentPassed++;
            
            console.log(`${desc}: "${short}" → "${long}"`);
            console.log(`  结果: ${actual}, 期望: ${expected} ${passed ? '✅' : '❌'}`);
            
            // 详细分析Unzen案例
            if (short === 'unzen (azur lane)') {
                console.log('  详细分析:');
                const shortParts = parseTagStructure(short);
                const longParts = parseTagStructure(long);
                console.log(`    短标签解析: 主词="${shortParts.mainWord}", 括号=[${shortParts.bracketContents.join(', ')}]`);
                console.log(`    长标签解析: 主词="${longParts.mainWord}", 括号=[${longParts.bracketContents.join(', ')}]`);
            }
        });
        
        console.log(`\n包含检测通过率: ${containmentPassed}/${containmentTests.length}`);
        
        // 完整简化测试
        const testCases = [
            {
                name: 'Unzen复杂词组测试（关键测试）',
                input: ['unzen (azur lane)', 'unzen (sojourn through clear seas) (azur lane)'],
                expected: ['unzen (sojourn through clear seas) (azur lane)']
            },
            {
                name: '避免部分匹配测试',
                input: ['censored', 'uncensored'],
                expected: ['censored', 'uncensored']
            },
            {
                name: '保持原始顺序测试',
                input: ['masterpiece', 'hat', 'blue eyes', 'red hat', 'girl'],
                expected: ['masterpiece', 'blue eyes', 'red hat', 'girl']
            }
        ];
        
        console.log('\n=== 完整简化测试 ===');
        let allPassed = true;
        const results = [];
        
        testCases.forEach((testCase, index) => {
            console.log(`\n测试 ${index + 1}: ${testCase.name}`);
            const actual = simplifyTagsFixed(testCase.input);
            const passed = JSON.stringify(actual) === JSON.stringify(testCase.expected);
            
            console.log(`输入: ${JSON.stringify(testCase.input)}`);
            console.log(`期望: ${JSON.stringify(testCase.expected)}`);
            console.log(`实际: ${JSON.stringify(actual)}`);
            console.log(`结果: ${passed ? '✅ 通过' : '❌ 失败'}`);
            
            if (!passed) allPassed = false;
            results.push({ ...testCase, actual, passed });
        });
        
        console.log(`\n=== 最终结果: ${allPassed ? '✅ 全部通过' : '❌ 部分失败'} ===`);
        
        // 页面显示结果
        const resultsHtml = results.map((result, index) => {
            const bgColor = result.passed ? '#e8f5e9' : '#ffebee';
            const borderColor = result.passed ? '#4CAF50' : '#f44336';
            
            return `
                <div style="margin: 15px; padding: 20px; border: 2px solid ${borderColor}; border-radius: 10px; background: ${bgColor};">
                    <h3>测试 ${index + 1}: ${result.name} ${result.passed ? '✅' : '❌'}</h3>
                    <p><strong>输入:</strong> ${JSON.stringify(result.input)}</p>
                    <p><strong>期望:</strong> ${JSON.stringify(result.expected)}</p>
                    <p><strong>实际:</strong> ${JSON.stringify(result.actual)}</p>
                </div>
            `;
        }).join('');
        
        document.body.innerHTML += `
            <div style="margin: 20px; font-family: Arial, sans-serif;">
                <h3 style="color: ${allPassed ? '#2e7d32' : '#c62828'};">
                    修复后测试结果: ${allPassed ? '✅ 全部通过' : '❌ 部分失败'}
                </h3>
                <p><strong>包含检测通过率:</strong> ${containmentPassed}/${containmentTests.length}</p>
                ${resultsHtml}
                <p><em>详细测试信息请查看浏览器控制台</em></p>
            </div>
        `;
    </script>
</body>
</html>